По скольку в условиях задачи не задано никаких ограничений по времени и памяти, то можно было бы просто производить прямой поиск подспоследовательности в последовательности. Но по-мимо наивного решения в голову пришло как минимум одно другое.
Оно заключается в том, чтобы искать в искомой подпоследовательности возрастающие числа (или их "куски").
Например пусть ищется подпоследовательность '88899'. Можно попытаться представить ещё в виде последовательностей одно-, дву-, трёх-, четырёх- и пятизначных чисел (кусков).
При чём она может начинаться как с полной записи числа (пример: строка 3), так и с его окончания (пример: строка 2).
В таблице показан пример всевозможных таких разбиений подпоследовательности '88899' на "куски". Здесь
chunk_size - количество десятичных разрядов в числах(кусках), на которые мы пытаемся дробить.
head - шаблон числа с которого начинается подпоследовательность
body - целые куски, на которые удалось разбить оставшуюся (с отсечённой головой) часть подпоследовательности
tail - шаблон-хвост (если он остался), оставшийся от разбиения на куски, аналогичен шаблону-голове.
Таким образом получается, что если подпоследовательность "вырезана" из последовательно идущих чисел одной кратности, то достаточно определить набор кусков, задающий последовательно идущие натуральные числа с минимальной кратностью куска.
Пусть подпоследовательность subseq задаёт число n (n = int(subseq), для примера получится n = int('88899')).
Тогда кратность числа m = len(subseq) ~ log(n, 10).
У меня получилась оценка скорости для предлагаемого метода O(m**2), при предположении, что "унификация" двух кусков есть неделимая операция ценой 1 у.е..
Под унификацией понимается определение того может ли быть следующий "кусок" путём увеличения числа, соответствующего предыдущему куску на 1.
Для прямого поиска в последовательности получаем O(n), опять же в предположении, что сравнение c подпоследовательностью является неделимой операцией ценой 1 у.е. (на самом-то деле получается O(n*m) в случае наивного алгоритма).

lineno	chunk_size	head	body					tail
1		1 			 8 		['8', '8', '9', '9'] 	''
2		2 			 *8 	['88', '99'] 			''
3		2 			 88 	['89'] 					9*
4		3 			 **8 	['889'] 				9**
5		3 			 *88 	['899'] 				''
6		3 			 888 	[] 						99*
7		4 			 ***8 	['8899'] 				''
8		4 			 **88 	[] 						899*
9		4 			 *888 	[] 						99**
10		4 			 8889 	[] 						9***
11		5 			 ****8 	[] 						8899*
12		5 			 ***88 	[] 						899**
13		5 			 **888 	[] 						99***
14		5 			 *8889 	[] 						9****
15		5 			 88899 	[] 						''
